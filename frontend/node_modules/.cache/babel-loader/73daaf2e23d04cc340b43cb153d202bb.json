{"ast":null,"code":"'use strict';\n\nconst is = require('./is');\n\nconst sharp = require('../build/Release/sharp.node');\n\nconst formats = new Map([['heic', 'heif'], ['heif', 'heif'], ['jpeg', 'jpeg'], ['jpg', 'jpeg'], ['png', 'png'], ['raw', 'raw'], ['tiff', 'tiff'], ['webp', 'webp']]);\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, TIFF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link withMetadata} for control over this.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {String} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\n\nfunction toFile(fileOut, callback) {\n  if (!fileOut || fileOut.length === 0) {\n    const errOutputInvalid = new Error('Missing output file path');\n\n    if (is.fn(callback)) {\n      callback(errOutputInvalid);\n    } else {\n      return Promise.reject(errOutputInvalid);\n    }\n  } else {\n    if (this.options.input.file === fileOut) {\n      const errOutputIsInput = new Error('Cannot use same file for input and output');\n\n      if (is.fn(callback)) {\n        callback(errOutputIsInput);\n      } else {\n        return Promise.reject(errOutputIsInput);\n      }\n    } else {\n      this.options.fileOut = fileOut;\n      return this._pipeline(callback);\n    }\n  }\n\n  return this;\n}\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, TIFF and RAW output are supported.\n *\n * If no explicit format is set, the output format will match the input image, except GIF and SVG input which become PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @param {Object} [options]\n * @param {Boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\n\n\nfunction toBuffer(options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n\n  return this._pipeline(is.fn(options) ? options : callback);\n}\n/**\n * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.\n * The default behaviour, when `withMetadata` is not used, is to strip all metadata and convert to the device-independent sRGB colour space.\n * This will also convert to and add a web-friendly sRGB ICC profile.\n *\n * @example\n * sharp('input.jpg')\n *   .withMetadata()\n *   .toFile('output-with-metadata.jpg')\n *   .then(info => { ... });\n *\n * @param {Object} [options]\n * @param {Number} [options.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction withMetadata(options) {\n  this.options.withMetadata = is.bool(options) ? options : true;\n\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n  }\n\n  return this;\n}\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(String|Object)} format - as a String or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\n\n\nfunction toFormat(format, options) {\n  const actualFormat = formats.get(is.object(format) && is.string(format.id) ? format.id : format);\n\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n\n  return this[actualFormat](options);\n}\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {String} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling when quality <= 90\n * @param {Boolean} [options.trellisQuantisation=false] - apply trellis quantisation, requires libvips compiled with support for mozjpeg\n * @param {Boolean} [options.overshootDeringing=false] - apply overshoot deringing, requires libvips compiled with support for mozjpeg\n * @param {Boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive, requires libvips compiled with support for mozjpeg\n * @param {Boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {Boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {Boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {Number} [options.quantisationTable=0] - quantization table to use, integer 0-8, requires libvips compiled with support for mozjpeg\n * @param {Number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {Boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction jpeg(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n\n  return this._updateFormatOut('jpeg', options);\n}\n/**\n * Use these PNG options for output image.\n *\n * PNG output is always full colour at 8 or 16 bits per pixel.\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {Boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {Number} [options.compressionLevel=9] - zlib compression level, 0-9\n * @param {Boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {Boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support, requires libvips compiled with support for libimagequant\n * @param {Number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, requires libvips compiled with support for libimagequant\n * @param {Number} [options.colours=256] - maximum number of palette entries, requires libvips compiled with support for libimagequant\n * @param {Number} [options.colors=256] - alternative spelling of `options.colours`, requires libvips compiled with support for libimagequant\n * @param {Number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, requires libvips compiled with support for libimagequant\n * @param {Boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction png(options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n\n      if (this.options.pngPalette) {\n        if (is.defined(options.quality)) {\n          if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n            this.options.pngQuality = options.quality;\n          } else {\n            throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n          }\n        }\n\n        const colours = options.colours || options.colors;\n\n        if (is.defined(colours)) {\n          if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n            this.options.pngColours = colours;\n          } else {\n            throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n          }\n        }\n\n        if (is.defined(options.dither)) {\n          if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n            this.options.pngDither = options.dither;\n          } else {\n            throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n          }\n        }\n      }\n    }\n  }\n\n  return this._updateFormatOut('png', options);\n}\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {Boolean} [options.lossless=false] - use lossless compression mode\n * @param {Boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {Boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {Number} [options.reductionEffort=4] - level of CPU effort to reduce file size, integer 0-6\n * @param {Boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction webp(options) {\n  if (is.object(options) && is.defined(options.quality)) {\n    if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n      this.options.webpQuality = options.quality;\n    } else {\n      throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n    }\n  }\n\n  if (is.object(options) && is.defined(options.alphaQuality)) {\n    if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n      this.options.webpAlphaQuality = options.alphaQuality;\n    } else {\n      throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n    }\n  }\n\n  if (is.object(options) && is.defined(options.lossless)) {\n    this._setBooleanOption('webpLossless', options.lossless);\n  }\n\n  if (is.object(options) && is.defined(options.nearLossless)) {\n    this._setBooleanOption('webpNearLossless', options.nearLossless);\n  }\n\n  if (is.object(options) && is.defined(options.smartSubsample)) {\n    this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n  }\n\n  if (is.object(options) && is.defined(options.reductionEffort)) {\n    if (is.integer(options.reductionEffort) && is.inRange(options.reductionEffort, 0, 6)) {\n      this.options.webpReductionEffort = options.reductionEffort;\n    } else {\n      throw is.invalidParameterError('reductionEffort', 'integer between 0 and 6', options.reductionEffort);\n    }\n  }\n\n  return this._updateFormatOut('webp', options);\n}\n/**\n * Use these TIFF options for output image.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     squash: true\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {Boolean} [options.compression='jpeg'] - compression options: lzw, deflate, jpeg, ccittfax4\n * @param {Boolean} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {Boolean} [options.pyramid=false] - write an image pyramid\n * @param {Boolean} [options.tile=false] - write a tiled tiff\n * @param {Boolean} [options.tileWidth=256] - horizontal tile size\n * @param {Boolean} [options.tileHeight=256] - vertical tile size\n * @param {Number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {Number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {Boolean} [options.squash=false] - squash 8-bit images down to 1 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction tiff(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n\n    if (is.defined(options.squash)) {\n      this._setBooleanOption('tiffSquash', options.squash);\n    } // tiling\n\n\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    } // pyramid\n\n\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    } // resolution\n\n\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    } // compression\n\n\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['lzw', 'deflate', 'jpeg', 'ccittfax4', 'none'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: lzw, deflate, jpeg, ccittfax4, none', options.compression);\n      }\n    } // predictor\n\n\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n  }\n\n  return this._updateFormatOut('tiff', options);\n}\n/**\n * Use these HEIF options for output image.\n *\n * Support for HEIF (HEIC/AVIF) is experimental.\n * Do not use this in production systems.\n *\n * Requires a custom, globally-installed libvips compiled with support for libheif.\n *\n * Most versions of libheif support only the patent-encumbered HEVC compression format.\n *\n * @since 0.23.0\n *\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Boolean} [options.compression='hevc'] - compression format: hevc, avc, jpeg, av1\n * @param {Boolean} [options.lossless=false] - use lossless compression\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\n\n\nfunction heif(options) {\n  if (!this.constructor.format.heif.output.buffer) {\n    throw new Error('The heif operation requires libvips to have been installed with support for libheif');\n  }\n\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['hevc', 'avc', 'jpeg', 'av1'])) {\n        this.options.heifCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: hevc, avc, jpeg, av1', options.compression);\n      }\n    }\n  }\n\n  return this._updateFormatOut('heif', options);\n}\n/**\n * Force output to be raw, uncompressed uint8 pixel data.\n *\n * @example\n * // Extract raw RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @returns {Sharp}\n */\n\n\nfunction raw() {\n  return this._updateFormatOut('raw');\n}\n/**\n * Use tile-based deep zoom (image pyramid) output.\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * Warning: multiple sharp instances concurrently producing tile output can expose a possible race condition in some versions of libgsf.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @param {Object} [options]\n * @param {Number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {Number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {Number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {String|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {String} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {Number} [options.skipBlanks=-1] threshold to skip tile generation, a value 0 - 255 for 8-bit images or 0 - 65535 for 16-bit images\n * @param {String} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {String} [options.layout='dz'] filesystem layout, possible values are `dz`, `zoomify` or `google`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction tile(options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    } // Overlap of tiles, in pixels\n\n\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    } // Container\n\n\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    } // Layout\n\n\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, zoomify', options.layout);\n      }\n    } // Angle of rotation,\n\n\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    } // Background colour\n\n\n    this._setBackgroundColourOption('tileBackground', options.background); // Depth of tiles\n\n\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    } // Threshold to skip blank tiles\n\n\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n  } // Format\n\n\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n\n  return this._updateFormatOut('dz');\n}\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {String} formatOut\n * @param {Object} [options]\n * @param {Boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\n\n\nfunction _updateFormatOut(formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n\n  return this;\n}\n/**\n * Update a Boolean attribute of the this.options Object.\n * @private\n * @param {String} key\n * @param {Boolean} val\n * @throws {Error} Invalid key\n */\n\n\nfunction _setBooleanOption(key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\n\n\nfunction _read() {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n\n    this._pipeline();\n  }\n}\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\n\n\nfunction _pipeline(callback) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n\n        sharp.pipeline(this.options, callback);\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, callback);\n    }\n\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n\n          this.push(null);\n        });\n      });\n\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', err);\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n\n        this.push(null);\n      });\n    }\n\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(err);\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({\n                  data,\n                  info\n                });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(err);\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({\n                data: data,\n                info: info\n              });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\n\n\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    withMetadata,\n    toFormat,\n    jpeg,\n    png,\n    webp,\n    tiff,\n    heif,\n    raw,\n    tile,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};","map":{"version":3,"sources":["/media/gabriel/HD/Cursos/OmniStack 7.0/aulas/node_modules/sharp/lib/output.js"],"names":["is","require","sharp","formats","Map","toFile","fileOut","callback","length","errOutputInvalid","Error","fn","Promise","reject","options","input","file","errOutputIsInput","_pipeline","toBuffer","object","_setBooleanOption","resolveWithObject","withMetadata","bool","defined","orientation","integer","inRange","withMetadataOrientation","invalidParameterError","toFormat","format","actualFormat","get","string","id","keys","join","jpeg","quality","jpegQuality","progressive","chromaSubsampling","inArray","jpegChromaSubsampling","trellisQuantisation","trellisQuantization","overshootDeringing","optimiseScans","optimizeScans","jpegProgressive","optimiseCoding","optimizeCoding","quantisationTable","number","quantizationTable","jpegQuantisationTable","_updateFormatOut","png","compressionLevel","pngCompressionLevel","adaptiveFiltering","palette","pngPalette","pngQuality","colours","colors","pngColours","dither","pngDither","webp","webpQuality","alphaQuality","webpAlphaQuality","lossless","nearLossless","smartSubsample","reductionEffort","webpReductionEffort","tiff","tiffQuality","squash","tile","tileWidth","tiffTileWidth","tileHeight","tiffTileHeight","pyramid","xres","tiffXres","yres","tiffYres","compression","tiffCompression","predictor","tiffPredictor","heif","constructor","output","buffer","heifQuality","heifLossless","heifCompression","raw","size","tileSize","overlap","tileOverlap","container","tileContainer","layout","tileLayout","angle","tileAngle","_setBackgroundColourOption","background","depth","tileDepth","skipBlanks","tileSkipBlanks","formatOut","tileFormat","force","key","val","_read","streamOut","_isStreamInput","on","_flattenBufferIn","pipeline","once","err","data","info","emit","push","streamInFinished","resolve","module","exports","Sharp","Object","assign","prototype"],"mappings":"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","sourcesContent":["'use strict';\n\nconst is = require('./is');\nconst sharp = require('../build/Release/sharp.node');\n\nconst formats = new Map([\n  ['heic', 'heif'],\n  ['heif', 'heif'],\n  ['jpeg', 'jpeg'],\n  ['jpg', 'jpeg'],\n  ['png', 'png'],\n  ['raw', 'raw'],\n  ['tiff', 'tiff'],\n  ['webp', 'webp']\n]);\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, TIFF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link withMetadata} for control over this.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {String} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile (fileOut, callback) {\n  if (!fileOut || fileOut.length === 0) {\n    const errOutputInvalid = new Error('Missing output file path');\n    if (is.fn(callback)) {\n      callback(errOutputInvalid);\n    } else {\n      return Promise.reject(errOutputInvalid);\n    }\n  } else {\n    if (this.options.input.file === fileOut) {\n      const errOutputIsInput = new Error('Cannot use same file for input and output');\n      if (is.fn(callback)) {\n        callback(errOutputIsInput);\n      } else {\n        return Promise.reject(errOutputIsInput);\n      }\n    } else {\n      this.options.fileOut = fileOut;\n      return this._pipeline(callback);\n    }\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, TIFF and RAW output are supported.\n *\n * If no explicit format is set, the output format will match the input image, except GIF and SVG input which become PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @param {Object} [options]\n * @param {Boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer (options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n  return this._pipeline(is.fn(options) ? options : callback);\n}\n\n/**\n * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.\n * The default behaviour, when `withMetadata` is not used, is to strip all metadata and convert to the device-independent sRGB colour space.\n * This will also convert to and add a web-friendly sRGB ICC profile.\n *\n * @example\n * sharp('input.jpg')\n *   .withMetadata()\n *   .toFile('output-with-metadata.jpg')\n *   .then(info => { ... });\n *\n * @param {Object} [options]\n * @param {Number} [options.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata (options) {\n  this.options.withMetadata = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(String|Object)} format - as a String or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat (format, options) {\n  const actualFormat = formats.get(is.object(format) && is.string(format.id) ? format.id : format);\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n  return this[actualFormat](options);\n}\n\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {String} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling when quality <= 90\n * @param {Boolean} [options.trellisQuantisation=false] - apply trellis quantisation, requires libvips compiled with support for mozjpeg\n * @param {Boolean} [options.overshootDeringing=false] - apply overshoot deringing, requires libvips compiled with support for mozjpeg\n * @param {Boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive, requires libvips compiled with support for mozjpeg\n * @param {Boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {Boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {Boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {Number} [options.quantisationTable=0] - quantization table to use, integer 0-8, requires libvips compiled with support for mozjpeg\n * @param {Number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {Boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n *\n * PNG output is always full colour at 8 or 16 bits per pixel.\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {Boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {Number} [options.compressionLevel=9] - zlib compression level, 0-9\n * @param {Boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {Boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support, requires libvips compiled with support for libimagequant\n * @param {Number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, requires libvips compiled with support for libimagequant\n * @param {Number} [options.colours=256] - maximum number of palette entries, requires libvips compiled with support for libimagequant\n * @param {Number} [options.colors=256] - alternative spelling of `options.colours`, requires libvips compiled with support for libimagequant\n * @param {Number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, requires libvips compiled with support for libimagequant\n * @param {Boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png (options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n      if (this.options.pngPalette) {\n        if (is.defined(options.quality)) {\n          if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n            this.options.pngQuality = options.quality;\n          } else {\n            throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n          }\n        }\n        const colours = options.colours || options.colors;\n        if (is.defined(colours)) {\n          if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n            this.options.pngColours = colours;\n          } else {\n            throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n          }\n        }\n        if (is.defined(options.dither)) {\n          if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n            this.options.pngDither = options.dither;\n          } else {\n            throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n          }\n        }\n      }\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {Boolean} [options.lossless=false] - use lossless compression mode\n * @param {Boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {Boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {Number} [options.reductionEffort=4] - level of CPU effort to reduce file size, integer 0-6\n * @param {Boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp (options) {\n  if (is.object(options) && is.defined(options.quality)) {\n    if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n      this.options.webpQuality = options.quality;\n    } else {\n      throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n    }\n  }\n  if (is.object(options) && is.defined(options.alphaQuality)) {\n    if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n      this.options.webpAlphaQuality = options.alphaQuality;\n    } else {\n      throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n    }\n  }\n  if (is.object(options) && is.defined(options.lossless)) {\n    this._setBooleanOption('webpLossless', options.lossless);\n  }\n  if (is.object(options) && is.defined(options.nearLossless)) {\n    this._setBooleanOption('webpNearLossless', options.nearLossless);\n  }\n  if (is.object(options) && is.defined(options.smartSubsample)) {\n    this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n  }\n  if (is.object(options) && is.defined(options.reductionEffort)) {\n    if (is.integer(options.reductionEffort) && is.inRange(options.reductionEffort, 0, 6)) {\n      this.options.webpReductionEffort = options.reductionEffort;\n    } else {\n      throw is.invalidParameterError('reductionEffort', 'integer between 0 and 6', options.reductionEffort);\n    }\n  }\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these TIFF options for output image.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     squash: true\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {Boolean} [options.compression='jpeg'] - compression options: lzw, deflate, jpeg, ccittfax4\n * @param {Boolean} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {Boolean} [options.pyramid=false] - write an image pyramid\n * @param {Boolean} [options.tile=false] - write a tiled tiff\n * @param {Boolean} [options.tileWidth=256] - horizontal tile size\n * @param {Boolean} [options.tileHeight=256] - vertical tile size\n * @param {Number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {Number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {Boolean} [options.squash=false] - squash 8-bit images down to 1 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.squash)) {\n      this._setBooleanOption('tiffSquash', options.squash);\n    }\n    // tiling\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    }\n    // pyramid\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    }\n    // resolution\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    }\n    // compression\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['lzw', 'deflate', 'jpeg', 'ccittfax4', 'none'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: lzw, deflate, jpeg, ccittfax4, none', options.compression);\n      }\n    }\n    // predictor\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Use these HEIF options for output image.\n *\n * Support for HEIF (HEIC/AVIF) is experimental.\n * Do not use this in production systems.\n *\n * Requires a custom, globally-installed libvips compiled with support for libheif.\n *\n * Most versions of libheif support only the patent-encumbered HEVC compression format.\n *\n * @since 0.23.0\n *\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Boolean} [options.compression='hevc'] - compression format: hevc, avc, jpeg, av1\n * @param {Boolean} [options.lossless=false] - use lossless compression\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction heif (options) {\n  if (!this.constructor.format.heif.output.buffer) {\n    throw new Error('The heif operation requires libvips to have been installed with support for libheif');\n  }\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['hevc', 'avc', 'jpeg', 'av1'])) {\n        this.options.heifCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: hevc, avc, jpeg, av1', options.compression);\n      }\n    }\n  }\n  return this._updateFormatOut('heif', options);\n}\n\n/**\n * Force output to be raw, uncompressed uint8 pixel data.\n *\n * @example\n * // Extract raw RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @returns {Sharp}\n */\nfunction raw () {\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * Warning: multiple sharp instances concurrently producing tile output can expose a possible race condition in some versions of libgsf.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @param {Object} [options]\n * @param {Number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {Number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {Number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {String|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {String} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {Number} [options.skipBlanks=-1] threshold to skip tile generation, a value 0 - 255 for 8-bit images or 0 - 65535 for 16-bit images\n * @param {String} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {String} [options.layout='dz'] filesystem layout, possible values are `dz`, `zoomify` or `google`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile (options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    }\n    // Container\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    }\n    // Layout\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, zoomify', options.layout);\n      }\n    }\n    // Angle of rotation,\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    }\n    // Background colour\n    this._setBackgroundColourOption('tileBackground', options.background);\n    // Depth of tiles\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    }\n    // Threshold to skip blank tiles\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {String} formatOut\n * @param {Object} [options]\n * @param {Boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut (formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n  return this;\n}\n\n/**\n * Update a Boolean attribute of the this.options Object.\n * @private\n * @param {String} key\n * @param {Boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption (key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read () {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    this._pipeline();\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline (callback) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, callback);\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, callback);\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n          this.push(null);\n        });\n      });\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', err);\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n        this.push(null);\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(err);\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({ data, info });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(err);\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({ data: data, info: info });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    withMetadata,\n    toFormat,\n    jpeg,\n    png,\n    webp,\n    tiff,\n    heif,\n    raw,\n    tile,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};\n"]},"metadata":{},"sourceType":"script"}