{"ast":null,"code":"'use strict';\n\nconst util = require('util');\n\nconst color = require('color');\n\nconst is = require('./is');\n\nconst sharp = require('../build/Release/sharp.node');\n/**\n * Create Object containing input and input-related options.\n * @private\n */\n\n\nfunction _createInputDescriptor(input, inputOptions, containerOptions) {\n  const inputDescriptor = {\n    failOnError: true,\n    limitInputPixels: Math.pow(0x3FFF, 2),\n    sequentialRead: false\n  };\n\n  if (is.string(input)) {\n    // filesystem\n    inputDescriptor.file = input;\n  } else if (is.buffer(input)) {\n    // Buffer\n    inputDescriptor.buffer = input;\n  } else if (is.plainObject(input) && !is.defined(inputOptions)) {\n    // Plain Object descriptor, e.g. create\n    inputOptions = input;\n\n    if (is.plainObject(inputOptions.raw) || is.bool(inputOptions.failOnError)) {\n      // Raw Stream\n      inputDescriptor.buffer = [];\n    }\n  } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {\n    // Stream\n    inputDescriptor.buffer = [];\n  } else {\n    throw new Error(`Unsupported input '${input}' of type ${typeof input}${is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ''}`);\n  }\n\n  if (is.object(inputOptions)) {\n    // Fail on error\n    if (is.defined(inputOptions.failOnError)) {\n      if (is.bool(inputOptions.failOnError)) {\n        inputDescriptor.failOnError = inputOptions.failOnError;\n      } else {\n        throw is.invalidParameterError('failOnError', 'boolean', inputOptions.failOnError);\n      }\n    } // Density\n\n\n    if (is.defined(inputOptions.density)) {\n      if (is.inRange(inputOptions.density, 1, 2400)) {\n        inputDescriptor.density = inputOptions.density;\n      } else {\n        throw is.invalidParameterError('density', 'number between 1 and 2400', inputOptions.density);\n      }\n    } // limitInputPixels\n\n\n    if (is.defined(inputOptions.limitInputPixels)) {\n      if (is.bool(inputOptions.limitInputPixels)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels ? Math.pow(0x3FFF, 2) : 0;\n      } else if (is.integer(inputOptions.limitInputPixels) && inputOptions.limitInputPixels >= 0) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;\n      } else {\n        throw is.invalidParameterError('limitInputPixels', 'integer >= 0', inputOptions.limitInputPixels);\n      }\n    } // sequentialRead\n\n\n    if (is.defined(inputOptions.sequentialRead)) {\n      if (is.bool(inputOptions.sequentialRead)) {\n        inputDescriptor.sequentialRead = inputOptions.sequentialRead;\n      } else {\n        throw is.invalidParameterError('sequentialRead', 'boolean', inputOptions.sequentialRead);\n      }\n    } // Raw pixel input\n\n\n    if (is.defined(inputOptions.raw)) {\n      if (is.object(inputOptions.raw) && is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)) {\n        inputDescriptor.rawWidth = inputOptions.raw.width;\n        inputDescriptor.rawHeight = inputOptions.raw.height;\n        inputDescriptor.rawChannels = inputOptions.raw.channels;\n      } else {\n        throw new Error('Expected width, height and channels for raw pixel input');\n      }\n    } // Multi-page input (GIF, TIFF, PDF)\n\n\n    if (is.defined(inputOptions.pages)) {\n      if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 100000)) {\n        inputDescriptor.pages = inputOptions.pages;\n      } else {\n        throw is.invalidParameterError('pages', 'integer between -1 and 100000', inputOptions.pages);\n      }\n    }\n\n    if (is.defined(inputOptions.page)) {\n      if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 100000)) {\n        inputDescriptor.page = inputOptions.page;\n      } else {\n        throw is.invalidParameterError('page', 'integer between 0 and 100000', inputOptions.page);\n      }\n    } // Create new image\n\n\n    if (is.defined(inputOptions.create)) {\n      if (is.object(inputOptions.create) && is.integer(inputOptions.create.width) && inputOptions.create.width > 0 && is.integer(inputOptions.create.height) && inputOptions.create.height > 0 && is.integer(inputOptions.create.channels) && is.inRange(inputOptions.create.channels, 3, 4) && is.defined(inputOptions.create.background)) {\n        inputDescriptor.createWidth = inputOptions.create.width;\n        inputDescriptor.createHeight = inputOptions.create.height;\n        inputDescriptor.createChannels = inputOptions.create.channels;\n        const background = color(inputOptions.create.background);\n        inputDescriptor.createBackground = [background.red(), background.green(), background.blue(), Math.round(background.alpha() * 255)];\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected width, height, channels and background to create a new input image');\n      }\n    }\n  } else if (is.defined(inputOptions)) {\n    throw new Error('Invalid input options ' + inputOptions);\n  }\n\n  return inputDescriptor;\n}\n/**\n * Handle incoming Buffer chunk on Writable Stream.\n * @private\n * @param {Buffer} chunk\n * @param {String} encoding - unused\n * @param {Function} callback\n */\n\n\nfunction _write(chunk, encoding, callback) {\n  /* istanbul ignore else */\n  if (Array.isArray(this.options.input.buffer)) {\n    /* istanbul ignore else */\n    if (is.buffer(chunk)) {\n      if (this.options.input.buffer.length === 0) {\n        this.on('finish', () => {\n          this.streamInFinished = true;\n        });\n      }\n\n      this.options.input.buffer.push(chunk);\n      callback();\n    } else {\n      callback(new Error('Non-Buffer data on Writable Stream'));\n    }\n  } else {\n    callback(new Error('Unexpected data on Writable Stream'));\n  }\n}\n/**\n * Flattens the array of chunks accumulated in input.buffer.\n * @private\n */\n\n\nfunction _flattenBufferIn() {\n  if (this._isStreamInput()) {\n    this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n  }\n}\n/**\n * Are we expecting Stream-based input?\n * @private\n * @returns {Boolean}\n */\n\n\nfunction _isStreamInput() {\n  return Array.isArray(this.options.input.buffer);\n}\n/**\n * Fast access to (uncached) image metadata without decoding any compressed image data.\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `format`: Name of decoder used to decompress image data e.g. `jpeg`, `png`, `webp`, `gif`, `svg`\n * - `size`: Total size of image in bytes, for Stream and Buffer input only\n * - `width`: Number of pixels wide (EXIF orientation is not taken into consideration)\n * - `height`: Number of pixels high (EXIF orientation is not taken into consideration)\n * - `space`: Name of colour space interpretation e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://libvips.github.io/libvips/API/current/VipsImage.html#VipsInterpretation)\n * - `channels`: Number of bands e.g. `3` for sRGB, `4` for CMYK\n * - `depth`: Name of pixel depth format e.g. `uchar`, `char`, `ushort`, `float` [...](https://libvips.github.io/libvips/API/current/VipsImage.html#VipsBandFormat)\n * - `density`: Number of pixels per inch (DPI), if present\n * - `chromaSubsampling`: String containing JPEG chroma subsampling, `4:2:0` or `4:4:4` for RGB, `4:2:0:4` or `4:4:4:4` for CMYK\n * - `isProgressive`: Boolean indicating whether the image is interlaced using a progressive scan\n * - `pages`: Number of pages/frames contained within the image, with support for TIFF, HEIF, PDF, animated GIF and animated WebP\n * - `pageHeight`: Number of pixels high each page in a multi-page image will be.\n * - `loop`: Number of times to loop an animated image, zero refers to a continuous loop.\n * - `delay`: Delay in ms between each page in an animated image, provided as an array of integers.\n * - `pagePrimary`: Number of the primary page in a HEIF image\n * - `hasProfile`: Boolean indicating the presence of an embedded ICC profile\n * - `hasAlpha`: Boolean indicating the presence of an alpha transparency channel\n * - `orientation`: Number value of the EXIF Orientation header, if present\n * - `exif`: Buffer containing raw EXIF data, if present\n * - `icc`: Buffer containing raw [ICC](https://www.npmjs.com/package/icc) profile data, if present\n * - `iptc`: Buffer containing raw IPTC data, if present\n * - `xmp`: Buffer containing raw XMP data, if present\n * - `tifftagPhotoshop`: Buffer containing raw TIFFTAG_PHOTOSHOP data, if present\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .metadata()\n *   .then(function(metadata) {\n *     return image\n *       .resize(Math.round(metadata.width / 2))\n *       .webp()\n *       .toBuffer();\n *   })\n *   .then(function(data) {\n *     // data contains a WebP image half the width and height of the original JPEG\n *   });\n *\n * @param {Function} [callback] - called with the arguments `(err, metadata)`\n * @returns {Promise<Object>|Sharp}\n */\n\n\nfunction metadata(callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n\n        sharp.metadata(this.options, callback);\n      });\n    } else {\n      sharp.metadata(this.options, callback);\n    }\n\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        this.on('finish', () => {\n          this._flattenBufferIn();\n\n          sharp.metadata(this.options, (err, metadata) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(metadata);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.metadata(this.options, (err, metadata) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(metadata);\n          }\n        });\n      });\n    }\n  }\n}\n/**\n * Access to pixel-derived image statistics for every channel in the image.\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `channels`: Array of channel statistics for each channel in the image. Each channel statistic contains\n *     - `min` (minimum value in the channel)\n *     - `max` (maximum value in the channel)\n *     - `sum` (sum of all values in a channel)\n *     - `squaresSum` (sum of squared values in a channel)\n *     - `mean` (mean of the values in a channel)\n *     - `stdev` (standard deviation for the values in a channel)\n *     - `minX` (x-coordinate of one of the pixel where the minimum lies)\n *     - `minY` (y-coordinate of one of the pixel where the minimum lies)\n *     - `maxX` (x-coordinate of one of the pixel where the maximum lies)\n *     - `maxY` (y-coordinate of one of the pixel where the maximum lies)\n * - `isOpaque`: Value to identify if the image is opaque or transparent, based on the presence and use of alpha channel\n * - `entropy`: Histogram-based estimation of greyscale entropy, discarding alpha channel if any (experimental)\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .stats()\n *   .then(function(stats) {\n *      // stats contains the channel-wise statistics array and the isOpaque value\n *   });\n *\n * @param {Function} [callback] - called with the arguments `(err, stats)`\n * @returns {Promise<Object>}\n */\n\n\nfunction stats(callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n\n        sharp.stats(this.options, callback);\n      });\n    } else {\n      sharp.stats(this.options, callback);\n    }\n\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        this.on('finish', function () {\n          this._flattenBufferIn();\n\n          sharp.stats(this.options, (err, stats) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(stats);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.stats(this.options, (err, stats) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(stats);\n          }\n        });\n      });\n    }\n  }\n}\n/**\n * @private\n */\n\n\nconst limitInputPixels = util.deprecate(function limitInputPixels(limit) {\n  // if we pass in false we represent the integer as 0 to disable\n  if (limit === false) {\n    limit = 0;\n  } else if (limit === true) {\n    limit = Math.pow(0x3FFF, 2);\n  }\n\n  if (is.integer(limit) && limit >= 0) {\n    this.options.input.limitInputPixels = limit;\n  } else {\n    throw is.invalidParameterError('limitInputPixels', 'integer', limit);\n  }\n\n  return this;\n}, 'limitInputPixels is deprecated, use sharp(input, { limitInputPixels: false }) instead');\n/**\n * @private\n */\n\nconst sequentialRead = util.deprecate(function sequentialRead(sequentialRead) {\n  this.options.input.sequentialRead = is.bool(sequentialRead) ? sequentialRead : true;\n  return this;\n}, 'sequentialRead is deprecated, use sharp(input, { sequentialRead: true }) instead');\n/**\n * Decorate the Sharp prototype with input-related functions.\n * @private\n */\n\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Private\n    _createInputDescriptor,\n    _write,\n    _flattenBufferIn,\n    _isStreamInput,\n    // Public\n    metadata,\n    stats,\n    // Deprecated\n    limitInputPixels,\n    sequentialRead\n  });\n};","map":{"version":3,"sources":["/media/gabriel/HD/Cursos/OmniStack 7.0/aulas/node_modules/sharp/lib/input.js"],"names":["util","require","color","is","sharp","_createInputDescriptor","input","inputOptions","containerOptions","inputDescriptor","failOnError","limitInputPixels","Math","pow","sequentialRead","string","file","buffer","plainObject","defined","raw","bool","object","allowStream","Error","invalidParameterError","density","inRange","integer","width","height","channels","rawWidth","rawHeight","rawChannels","pages","page","create","background","createWidth","createHeight","createChannels","createBackground","red","green","blue","round","alpha","_write","chunk","encoding","callback","Array","isArray","options","length","on","streamInFinished","push","_flattenBufferIn","_isStreamInput","Buffer","concat","metadata","fn","Promise","resolve","reject","err","stats","deprecate","limit","module","exports","Sharp","Object","assign","prototype"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,6BAAD,CAArB;AAEA;;;;;;AAIA,SAASI,sBAAT,CAAiCC,KAAjC,EAAwCC,YAAxC,EAAsDC,gBAAtD,EAAwE;AACtE,QAAMC,eAAe,GAAG;AACtBC,IAAAA,WAAW,EAAE,IADS;AAEtBC,IAAAA,gBAAgB,EAAEC,IAAI,CAACC,GAAL,CAAS,MAAT,EAAiB,CAAjB,CAFI;AAGtBC,IAAAA,cAAc,EAAE;AAHM,GAAxB;;AAKA,MAAIX,EAAE,CAACY,MAAH,CAAUT,KAAV,CAAJ,EAAsB;AACpB;AACAG,IAAAA,eAAe,CAACO,IAAhB,GAAuBV,KAAvB;AACD,GAHD,MAGO,IAAIH,EAAE,CAACc,MAAH,CAAUX,KAAV,CAAJ,EAAsB;AAC3B;AACAG,IAAAA,eAAe,CAACQ,MAAhB,GAAyBX,KAAzB;AACD,GAHM,MAGA,IAAIH,EAAE,CAACe,WAAH,CAAeZ,KAAf,KAAyB,CAACH,EAAE,CAACgB,OAAH,CAAWZ,YAAX,CAA9B,EAAwD;AAC7D;AACAA,IAAAA,YAAY,GAAGD,KAAf;;AACA,QAAIH,EAAE,CAACe,WAAH,CAAeX,YAAY,CAACa,GAA5B,KAAoCjB,EAAE,CAACkB,IAAH,CAAQd,YAAY,CAACG,WAArB,CAAxC,EAA2E;AACzE;AACAD,MAAAA,eAAe,CAACQ,MAAhB,GAAyB,EAAzB;AACD;AACF,GAPM,MAOA,IAAI,CAACd,EAAE,CAACgB,OAAH,CAAWb,KAAX,CAAD,IAAsB,CAACH,EAAE,CAACgB,OAAH,CAAWZ,YAAX,CAAvB,IAAmDJ,EAAE,CAACmB,MAAH,CAAUd,gBAAV,CAAnD,IAAkFA,gBAAgB,CAACe,WAAvG,EAAoH;AACzH;AACAd,IAAAA,eAAe,CAACQ,MAAhB,GAAyB,EAAzB;AACD,GAHM,MAGA;AACL,UAAM,IAAIO,KAAJ,CAAW,sBAAqBlB,KAAM,aAAY,OAAOA,KAAM,GACnEH,EAAE,CAACgB,OAAH,CAAWZ,YAAX,IAA4B,wCAAuC,OAAOA,YAAa,EAAvF,GAA2F,EAC5F,EAFK,CAAN;AAGD;;AACD,MAAIJ,EAAE,CAACmB,MAAH,CAAUf,YAAV,CAAJ,EAA6B;AAC3B;AACA,QAAIJ,EAAE,CAACgB,OAAH,CAAWZ,YAAY,CAACG,WAAxB,CAAJ,EAA0C;AACxC,UAAIP,EAAE,CAACkB,IAAH,CAAQd,YAAY,CAACG,WAArB,CAAJ,EAAuC;AACrCD,QAAAA,eAAe,CAACC,WAAhB,GAA8BH,YAAY,CAACG,WAA3C;AACD,OAFD,MAEO;AACL,cAAMP,EAAE,CAACsB,qBAAH,CAAyB,aAAzB,EAAwC,SAAxC,EAAmDlB,YAAY,CAACG,WAAhE,CAAN;AACD;AACF,KAR0B,CAS3B;;;AACA,QAAIP,EAAE,CAACgB,OAAH,CAAWZ,YAAY,CAACmB,OAAxB,CAAJ,EAAsC;AACpC,UAAIvB,EAAE,CAACwB,OAAH,CAAWpB,YAAY,CAACmB,OAAxB,EAAiC,CAAjC,EAAoC,IAApC,CAAJ,EAA+C;AAC7CjB,QAAAA,eAAe,CAACiB,OAAhB,GAA0BnB,YAAY,CAACmB,OAAvC;AACD,OAFD,MAEO;AACL,cAAMvB,EAAE,CAACsB,qBAAH,CAAyB,SAAzB,EAAoC,2BAApC,EAAiElB,YAAY,CAACmB,OAA9E,CAAN;AACD;AACF,KAhB0B,CAiB3B;;;AACA,QAAIvB,EAAE,CAACgB,OAAH,CAAWZ,YAAY,CAACI,gBAAxB,CAAJ,EAA+C;AAC7C,UAAIR,EAAE,CAACkB,IAAH,CAAQd,YAAY,CAACI,gBAArB,CAAJ,EAA4C;AAC1CF,QAAAA,eAAe,CAACE,gBAAhB,GAAmCJ,YAAY,CAACI,gBAAb,GAC/BC,IAAI,CAACC,GAAL,CAAS,MAAT,EAAiB,CAAjB,CAD+B,GAE/B,CAFJ;AAGD,OAJD,MAIO,IAAIV,EAAE,CAACyB,OAAH,CAAWrB,YAAY,CAACI,gBAAxB,KAA6CJ,YAAY,CAACI,gBAAb,IAAiC,CAAlF,EAAqF;AAC1FF,QAAAA,eAAe,CAACE,gBAAhB,GAAmCJ,YAAY,CAACI,gBAAhD;AACD,OAFM,MAEA;AACL,cAAMR,EAAE,CAACsB,qBAAH,CAAyB,kBAAzB,EAA6C,cAA7C,EAA6DlB,YAAY,CAACI,gBAA1E,CAAN;AACD;AACF,KA5B0B,CA6B3B;;;AACA,QAAIR,EAAE,CAACgB,OAAH,CAAWZ,YAAY,CAACO,cAAxB,CAAJ,EAA6C;AAC3C,UAAIX,EAAE,CAACkB,IAAH,CAAQd,YAAY,CAACO,cAArB,CAAJ,EAA0C;AACxCL,QAAAA,eAAe,CAACK,cAAhB,GAAiCP,YAAY,CAACO,cAA9C;AACD,OAFD,MAEO;AACL,cAAMX,EAAE,CAACsB,qBAAH,CAAyB,gBAAzB,EAA2C,SAA3C,EAAsDlB,YAAY,CAACO,cAAnE,CAAN;AACD;AACF,KApC0B,CAqC3B;;;AACA,QAAIX,EAAE,CAACgB,OAAH,CAAWZ,YAAY,CAACa,GAAxB,CAAJ,EAAkC;AAChC,UACEjB,EAAE,CAACmB,MAAH,CAAUf,YAAY,CAACa,GAAvB,KACAjB,EAAE,CAACyB,OAAH,CAAWrB,YAAY,CAACa,GAAb,CAAiBS,KAA5B,CADA,IACsCtB,YAAY,CAACa,GAAb,CAAiBS,KAAjB,GAAyB,CAD/D,IAEA1B,EAAE,CAACyB,OAAH,CAAWrB,YAAY,CAACa,GAAb,CAAiBU,MAA5B,CAFA,IAEuCvB,YAAY,CAACa,GAAb,CAAiBU,MAAjB,GAA0B,CAFjE,IAGA3B,EAAE,CAACyB,OAAH,CAAWrB,YAAY,CAACa,GAAb,CAAiBW,QAA5B,CAHA,IAGyC5B,EAAE,CAACwB,OAAH,CAAWpB,YAAY,CAACa,GAAb,CAAiBW,QAA5B,EAAsC,CAAtC,EAAyC,CAAzC,CAJ3C,EAKE;AACAtB,QAAAA,eAAe,CAACuB,QAAhB,GAA2BzB,YAAY,CAACa,GAAb,CAAiBS,KAA5C;AACApB,QAAAA,eAAe,CAACwB,SAAhB,GAA4B1B,YAAY,CAACa,GAAb,CAAiBU,MAA7C;AACArB,QAAAA,eAAe,CAACyB,WAAhB,GAA8B3B,YAAY,CAACa,GAAb,CAAiBW,QAA/C;AACD,OATD,MASO;AACL,cAAM,IAAIP,KAAJ,CAAU,yDAAV,CAAN;AACD;AACF,KAnD0B,CAoD3B;;;AACA,QAAIrB,EAAE,CAACgB,OAAH,CAAWZ,YAAY,CAAC4B,KAAxB,CAAJ,EAAoC;AAClC,UAAIhC,EAAE,CAACyB,OAAH,CAAWrB,YAAY,CAAC4B,KAAxB,KAAkChC,EAAE,CAACwB,OAAH,CAAWpB,YAAY,CAAC4B,KAAxB,EAA+B,CAAC,CAAhC,EAAmC,MAAnC,CAAtC,EAAkF;AAChF1B,QAAAA,eAAe,CAAC0B,KAAhB,GAAwB5B,YAAY,CAAC4B,KAArC;AACD,OAFD,MAEO;AACL,cAAMhC,EAAE,CAACsB,qBAAH,CAAyB,OAAzB,EAAkC,+BAAlC,EAAmElB,YAAY,CAAC4B,KAAhF,CAAN;AACD;AACF;;AACD,QAAIhC,EAAE,CAACgB,OAAH,CAAWZ,YAAY,CAAC6B,IAAxB,CAAJ,EAAmC;AACjC,UAAIjC,EAAE,CAACyB,OAAH,CAAWrB,YAAY,CAAC6B,IAAxB,KAAiCjC,EAAE,CAACwB,OAAH,CAAWpB,YAAY,CAAC6B,IAAxB,EAA8B,CAA9B,EAAiC,MAAjC,CAArC,EAA+E;AAC7E3B,QAAAA,eAAe,CAAC2B,IAAhB,GAAuB7B,YAAY,CAAC6B,IAApC;AACD,OAFD,MAEO;AACL,cAAMjC,EAAE,CAACsB,qBAAH,CAAyB,MAAzB,EAAiC,8BAAjC,EAAiElB,YAAY,CAAC6B,IAA9E,CAAN;AACD;AACF,KAlE0B,CAmE3B;;;AACA,QAAIjC,EAAE,CAACgB,OAAH,CAAWZ,YAAY,CAAC8B,MAAxB,CAAJ,EAAqC;AACnC,UACElC,EAAE,CAACmB,MAAH,CAAUf,YAAY,CAAC8B,MAAvB,KACAlC,EAAE,CAACyB,OAAH,CAAWrB,YAAY,CAAC8B,MAAb,CAAoBR,KAA/B,CADA,IACyCtB,YAAY,CAAC8B,MAAb,CAAoBR,KAApB,GAA4B,CADrE,IAEA1B,EAAE,CAACyB,OAAH,CAAWrB,YAAY,CAAC8B,MAAb,CAAoBP,MAA/B,CAFA,IAE0CvB,YAAY,CAAC8B,MAAb,CAAoBP,MAApB,GAA6B,CAFvE,IAGA3B,EAAE,CAACyB,OAAH,CAAWrB,YAAY,CAAC8B,MAAb,CAAoBN,QAA/B,CAHA,IAG4C5B,EAAE,CAACwB,OAAH,CAAWpB,YAAY,CAAC8B,MAAb,CAAoBN,QAA/B,EAAyC,CAAzC,EAA4C,CAA5C,CAH5C,IAIA5B,EAAE,CAACgB,OAAH,CAAWZ,YAAY,CAAC8B,MAAb,CAAoBC,UAA/B,CALF,EAME;AACA7B,QAAAA,eAAe,CAAC8B,WAAhB,GAA8BhC,YAAY,CAAC8B,MAAb,CAAoBR,KAAlD;AACApB,QAAAA,eAAe,CAAC+B,YAAhB,GAA+BjC,YAAY,CAAC8B,MAAb,CAAoBP,MAAnD;AACArB,QAAAA,eAAe,CAACgC,cAAhB,GAAiClC,YAAY,CAAC8B,MAAb,CAAoBN,QAArD;AACA,cAAMO,UAAU,GAAGpC,KAAK,CAACK,YAAY,CAAC8B,MAAb,CAAoBC,UAArB,CAAxB;AACA7B,QAAAA,eAAe,CAACiC,gBAAhB,GAAmC,CACjCJ,UAAU,CAACK,GAAX,EADiC,EAEjCL,UAAU,CAACM,KAAX,EAFiC,EAGjCN,UAAU,CAACO,IAAX,EAHiC,EAIjCjC,IAAI,CAACkC,KAAL,CAAWR,UAAU,CAACS,KAAX,KAAqB,GAAhC,CAJiC,CAAnC;AAMA,eAAOtC,eAAe,CAACQ,MAAvB;AACD,OAlBD,MAkBO;AACL,cAAM,IAAIO,KAAJ,CAAU,6EAAV,CAAN;AACD;AACF;AACF,GA3FD,MA2FO,IAAIrB,EAAE,CAACgB,OAAH,CAAWZ,YAAX,CAAJ,EAA8B;AACnC,UAAM,IAAIiB,KAAJ,CAAU,2BAA2BjB,YAArC,CAAN;AACD;;AACD,SAAOE,eAAP;AACD;AAED;;;;;;;;;AAOA,SAASuC,MAAT,CAAiBC,KAAjB,EAAwBC,QAAxB,EAAkCC,QAAlC,EAA4C;AAC1C;AACA,MAAIC,KAAK,CAACC,OAAN,CAAc,KAAKC,OAAL,CAAahD,KAAb,CAAmBW,MAAjC,CAAJ,EAA8C;AAC5C;AACA,QAAId,EAAE,CAACc,MAAH,CAAUgC,KAAV,CAAJ,EAAsB;AACpB,UAAI,KAAKK,OAAL,CAAahD,KAAb,CAAmBW,MAAnB,CAA0BsC,MAA1B,KAAqC,CAAzC,EAA4C;AAC1C,aAAKC,EAAL,CAAQ,QAAR,EAAkB,MAAM;AACtB,eAAKC,gBAAL,GAAwB,IAAxB;AACD,SAFD;AAGD;;AACD,WAAKH,OAAL,CAAahD,KAAb,CAAmBW,MAAnB,CAA0ByC,IAA1B,CAA+BT,KAA/B;AACAE,MAAAA,QAAQ;AACT,KARD,MAQO;AACLA,MAAAA,QAAQ,CAAC,IAAI3B,KAAJ,CAAU,oCAAV,CAAD,CAAR;AACD;AACF,GAbD,MAaO;AACL2B,IAAAA,QAAQ,CAAC,IAAI3B,KAAJ,CAAU,oCAAV,CAAD,CAAR;AACD;AACF;AAED;;;;;;AAIA,SAASmC,gBAAT,GAA6B;AAC3B,MAAI,KAAKC,cAAL,EAAJ,EAA2B;AACzB,SAAKN,OAAL,CAAahD,KAAb,CAAmBW,MAAnB,GAA4B4C,MAAM,CAACC,MAAP,CAAc,KAAKR,OAAL,CAAahD,KAAb,CAAmBW,MAAjC,CAA5B;AACD;AACF;AAED;;;;;;;AAKA,SAAS2C,cAAT,GAA2B;AACzB,SAAOR,KAAK,CAACC,OAAN,CAAc,KAAKC,OAAL,CAAahD,KAAb,CAAmBW,MAAjC,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA,SAAS8C,QAAT,CAAmBZ,QAAnB,EAA6B;AAC3B,MAAIhD,EAAE,CAAC6D,EAAH,CAAMb,QAAN,CAAJ,EAAqB;AACnB,QAAI,KAAKS,cAAL,EAAJ,EAA2B;AACzB,WAAKJ,EAAL,CAAQ,QAAR,EAAkB,MAAM;AACtB,aAAKG,gBAAL;;AACAvD,QAAAA,KAAK,CAAC2D,QAAN,CAAe,KAAKT,OAApB,EAA6BH,QAA7B;AACD,OAHD;AAID,KALD,MAKO;AACL/C,MAAAA,KAAK,CAAC2D,QAAN,CAAe,KAAKT,OAApB,EAA6BH,QAA7B;AACD;;AACD,WAAO,IAAP;AACD,GAVD,MAUO;AACL,QAAI,KAAKS,cAAL,EAAJ,EAA2B;AACzB,aAAO,IAAIK,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,aAAKX,EAAL,CAAQ,QAAR,EAAkB,MAAM;AACtB,eAAKG,gBAAL;;AACAvD,UAAAA,KAAK,CAAC2D,QAAN,CAAe,KAAKT,OAApB,EAA6B,CAACc,GAAD,EAAML,QAAN,KAAmB;AAC9C,gBAAIK,GAAJ,EAAS;AACPD,cAAAA,MAAM,CAACC,GAAD,CAAN;AACD,aAFD,MAEO;AACLF,cAAAA,OAAO,CAACH,QAAD,CAAP;AACD;AACF,WAND;AAOD,SATD;AAUD,OAXM,CAAP;AAYD,KAbD,MAaO;AACL,aAAO,IAAIE,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC/D,QAAAA,KAAK,CAAC2D,QAAN,CAAe,KAAKT,OAApB,EAA6B,CAACc,GAAD,EAAML,QAAN,KAAmB;AAC9C,cAAIK,GAAJ,EAAS;AACPD,YAAAA,MAAM,CAACC,GAAD,CAAN;AACD,WAFD,MAEO;AACLF,YAAAA,OAAO,CAACH,QAAD,CAAP;AACD;AACF,SAND;AAOD,OARM,CAAP;AASD;AACF;AACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,SAASM,KAAT,CAAgBlB,QAAhB,EAA0B;AACxB,MAAIhD,EAAE,CAAC6D,EAAH,CAAMb,QAAN,CAAJ,EAAqB;AACnB,QAAI,KAAKS,cAAL,EAAJ,EAA2B;AACzB,WAAKJ,EAAL,CAAQ,QAAR,EAAkB,MAAM;AACtB,aAAKG,gBAAL;;AACAvD,QAAAA,KAAK,CAACiE,KAAN,CAAY,KAAKf,OAAjB,EAA0BH,QAA1B;AACD,OAHD;AAID,KALD,MAKO;AACL/C,MAAAA,KAAK,CAACiE,KAAN,CAAY,KAAKf,OAAjB,EAA0BH,QAA1B;AACD;;AACD,WAAO,IAAP;AACD,GAVD,MAUO;AACL,QAAI,KAAKS,cAAL,EAAJ,EAA2B;AACzB,aAAO,IAAIK,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,aAAKX,EAAL,CAAQ,QAAR,EAAkB,YAAY;AAC5B,eAAKG,gBAAL;;AACAvD,UAAAA,KAAK,CAACiE,KAAN,CAAY,KAAKf,OAAjB,EAA0B,CAACc,GAAD,EAAMC,KAAN,KAAgB;AACxC,gBAAID,GAAJ,EAAS;AACPD,cAAAA,MAAM,CAACC,GAAD,CAAN;AACD,aAFD,MAEO;AACLF,cAAAA,OAAO,CAACG,KAAD,CAAP;AACD;AACF,WAND;AAOD,SATD;AAUD,OAXM,CAAP;AAYD,KAbD,MAaO;AACL,aAAO,IAAIJ,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC/D,QAAAA,KAAK,CAACiE,KAAN,CAAY,KAAKf,OAAjB,EAA0B,CAACc,GAAD,EAAMC,KAAN,KAAgB;AACxC,cAAID,GAAJ,EAAS;AACPD,YAAAA,MAAM,CAACC,GAAD,CAAN;AACD,WAFD,MAEO;AACLF,YAAAA,OAAO,CAACG,KAAD,CAAP;AACD;AACF,SAND;AAOD,OARM,CAAP;AASD;AACF;AACF;AAED;;;;;AAGA,MAAM1D,gBAAgB,GAAGX,IAAI,CAACsE,SAAL,CAAe,SAAS3D,gBAAT,CAA2B4D,KAA3B,EAAkC;AACxE;AACA,MAAIA,KAAK,KAAK,KAAd,EAAqB;AACnBA,IAAAA,KAAK,GAAG,CAAR;AACD,GAFD,MAEO,IAAIA,KAAK,KAAK,IAAd,EAAoB;AACzBA,IAAAA,KAAK,GAAG3D,IAAI,CAACC,GAAL,CAAS,MAAT,EAAiB,CAAjB,CAAR;AACD;;AACD,MAAIV,EAAE,CAACyB,OAAH,CAAW2C,KAAX,KAAqBA,KAAK,IAAI,CAAlC,EAAqC;AACnC,SAAKjB,OAAL,CAAahD,KAAb,CAAmBK,gBAAnB,GAAsC4D,KAAtC;AACD,GAFD,MAEO;AACL,UAAMpE,EAAE,CAACsB,qBAAH,CAAyB,kBAAzB,EAA6C,SAA7C,EAAwD8C,KAAxD,CAAN;AACD;;AACD,SAAO,IAAP;AACD,CAbwB,EAatB,uFAbsB,CAAzB;AAeA;;;;AAGA,MAAMzD,cAAc,GAAGd,IAAI,CAACsE,SAAL,CAAe,SAASxD,cAAT,CAAyBA,cAAzB,EAAyC;AAC7E,OAAKwC,OAAL,CAAahD,KAAb,CAAmBQ,cAAnB,GAAoCX,EAAE,CAACkB,IAAH,CAAQP,cAAR,IAA0BA,cAA1B,GAA2C,IAA/E;AACA,SAAO,IAAP;AACD,CAHsB,EAGpB,kFAHoB,CAAvB;AAKA;;;;;AAIA0D,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AAChCC,EAAAA,MAAM,CAACC,MAAP,CAAcF,KAAK,CAACG,SAApB,EAA+B;AAC7B;AACAxE,IAAAA,sBAF6B;AAG7B2C,IAAAA,MAH6B;AAI7BW,IAAAA,gBAJ6B;AAK7BC,IAAAA,cAL6B;AAM7B;AACAG,IAAAA,QAP6B;AAQ7BM,IAAAA,KAR6B;AAS7B;AACA1D,IAAAA,gBAV6B;AAW7BG,IAAAA;AAX6B,GAA/B;AAaD,CAdD","sourcesContent":["'use strict';\n\nconst util = require('util');\nconst color = require('color');\nconst is = require('./is');\nconst sharp = require('../build/Release/sharp.node');\n\n/**\n * Create Object containing input and input-related options.\n * @private\n */\nfunction _createInputDescriptor (input, inputOptions, containerOptions) {\n  const inputDescriptor = {\n    failOnError: true,\n    limitInputPixels: Math.pow(0x3FFF, 2),\n    sequentialRead: false\n  };\n  if (is.string(input)) {\n    // filesystem\n    inputDescriptor.file = input;\n  } else if (is.buffer(input)) {\n    // Buffer\n    inputDescriptor.buffer = input;\n  } else if (is.plainObject(input) && !is.defined(inputOptions)) {\n    // Plain Object descriptor, e.g. create\n    inputOptions = input;\n    if (is.plainObject(inputOptions.raw) || is.bool(inputOptions.failOnError)) {\n      // Raw Stream\n      inputDescriptor.buffer = [];\n    }\n  } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {\n    // Stream\n    inputDescriptor.buffer = [];\n  } else {\n    throw new Error(`Unsupported input '${input}' of type ${typeof input}${\n      is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ''\n    }`);\n  }\n  if (is.object(inputOptions)) {\n    // Fail on error\n    if (is.defined(inputOptions.failOnError)) {\n      if (is.bool(inputOptions.failOnError)) {\n        inputDescriptor.failOnError = inputOptions.failOnError;\n      } else {\n        throw is.invalidParameterError('failOnError', 'boolean', inputOptions.failOnError);\n      }\n    }\n    // Density\n    if (is.defined(inputOptions.density)) {\n      if (is.inRange(inputOptions.density, 1, 2400)) {\n        inputDescriptor.density = inputOptions.density;\n      } else {\n        throw is.invalidParameterError('density', 'number between 1 and 2400', inputOptions.density);\n      }\n    }\n    // limitInputPixels\n    if (is.defined(inputOptions.limitInputPixels)) {\n      if (is.bool(inputOptions.limitInputPixels)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels\n          ? Math.pow(0x3FFF, 2)\n          : 0;\n      } else if (is.integer(inputOptions.limitInputPixels) && inputOptions.limitInputPixels >= 0) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;\n      } else {\n        throw is.invalidParameterError('limitInputPixels', 'integer >= 0', inputOptions.limitInputPixels);\n      }\n    }\n    // sequentialRead\n    if (is.defined(inputOptions.sequentialRead)) {\n      if (is.bool(inputOptions.sequentialRead)) {\n        inputDescriptor.sequentialRead = inputOptions.sequentialRead;\n      } else {\n        throw is.invalidParameterError('sequentialRead', 'boolean', inputOptions.sequentialRead);\n      }\n    }\n    // Raw pixel input\n    if (is.defined(inputOptions.raw)) {\n      if (\n        is.object(inputOptions.raw) &&\n        is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 &&\n        is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 &&\n        is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)\n      ) {\n        inputDescriptor.rawWidth = inputOptions.raw.width;\n        inputDescriptor.rawHeight = inputOptions.raw.height;\n        inputDescriptor.rawChannels = inputOptions.raw.channels;\n      } else {\n        throw new Error('Expected width, height and channels for raw pixel input');\n      }\n    }\n    // Multi-page input (GIF, TIFF, PDF)\n    if (is.defined(inputOptions.pages)) {\n      if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 100000)) {\n        inputDescriptor.pages = inputOptions.pages;\n      } else {\n        throw is.invalidParameterError('pages', 'integer between -1 and 100000', inputOptions.pages);\n      }\n    }\n    if (is.defined(inputOptions.page)) {\n      if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 100000)) {\n        inputDescriptor.page = inputOptions.page;\n      } else {\n        throw is.invalidParameterError('page', 'integer between 0 and 100000', inputOptions.page);\n      }\n    }\n    // Create new image\n    if (is.defined(inputOptions.create)) {\n      if (\n        is.object(inputOptions.create) &&\n        is.integer(inputOptions.create.width) && inputOptions.create.width > 0 &&\n        is.integer(inputOptions.create.height) && inputOptions.create.height > 0 &&\n        is.integer(inputOptions.create.channels) && is.inRange(inputOptions.create.channels, 3, 4) &&\n        is.defined(inputOptions.create.background)\n      ) {\n        inputDescriptor.createWidth = inputOptions.create.width;\n        inputDescriptor.createHeight = inputOptions.create.height;\n        inputDescriptor.createChannels = inputOptions.create.channels;\n        const background = color(inputOptions.create.background);\n        inputDescriptor.createBackground = [\n          background.red(),\n          background.green(),\n          background.blue(),\n          Math.round(background.alpha() * 255)\n        ];\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected width, height, channels and background to create a new input image');\n      }\n    }\n  } else if (is.defined(inputOptions)) {\n    throw new Error('Invalid input options ' + inputOptions);\n  }\n  return inputDescriptor;\n}\n\n/**\n * Handle incoming Buffer chunk on Writable Stream.\n * @private\n * @param {Buffer} chunk\n * @param {String} encoding - unused\n * @param {Function} callback\n */\nfunction _write (chunk, encoding, callback) {\n  /* istanbul ignore else */\n  if (Array.isArray(this.options.input.buffer)) {\n    /* istanbul ignore else */\n    if (is.buffer(chunk)) {\n      if (this.options.input.buffer.length === 0) {\n        this.on('finish', () => {\n          this.streamInFinished = true;\n        });\n      }\n      this.options.input.buffer.push(chunk);\n      callback();\n    } else {\n      callback(new Error('Non-Buffer data on Writable Stream'));\n    }\n  } else {\n    callback(new Error('Unexpected data on Writable Stream'));\n  }\n}\n\n/**\n * Flattens the array of chunks accumulated in input.buffer.\n * @private\n */\nfunction _flattenBufferIn () {\n  if (this._isStreamInput()) {\n    this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n  }\n}\n\n/**\n * Are we expecting Stream-based input?\n * @private\n * @returns {Boolean}\n */\nfunction _isStreamInput () {\n  return Array.isArray(this.options.input.buffer);\n}\n\n/**\n * Fast access to (uncached) image metadata without decoding any compressed image data.\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `format`: Name of decoder used to decompress image data e.g. `jpeg`, `png`, `webp`, `gif`, `svg`\n * - `size`: Total size of image in bytes, for Stream and Buffer input only\n * - `width`: Number of pixels wide (EXIF orientation is not taken into consideration)\n * - `height`: Number of pixels high (EXIF orientation is not taken into consideration)\n * - `space`: Name of colour space interpretation e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://libvips.github.io/libvips/API/current/VipsImage.html#VipsInterpretation)\n * - `channels`: Number of bands e.g. `3` for sRGB, `4` for CMYK\n * - `depth`: Name of pixel depth format e.g. `uchar`, `char`, `ushort`, `float` [...](https://libvips.github.io/libvips/API/current/VipsImage.html#VipsBandFormat)\n * - `density`: Number of pixels per inch (DPI), if present\n * - `chromaSubsampling`: String containing JPEG chroma subsampling, `4:2:0` or `4:4:4` for RGB, `4:2:0:4` or `4:4:4:4` for CMYK\n * - `isProgressive`: Boolean indicating whether the image is interlaced using a progressive scan\n * - `pages`: Number of pages/frames contained within the image, with support for TIFF, HEIF, PDF, animated GIF and animated WebP\n * - `pageHeight`: Number of pixels high each page in a multi-page image will be.\n * - `loop`: Number of times to loop an animated image, zero refers to a continuous loop.\n * - `delay`: Delay in ms between each page in an animated image, provided as an array of integers.\n * - `pagePrimary`: Number of the primary page in a HEIF image\n * - `hasProfile`: Boolean indicating the presence of an embedded ICC profile\n * - `hasAlpha`: Boolean indicating the presence of an alpha transparency channel\n * - `orientation`: Number value of the EXIF Orientation header, if present\n * - `exif`: Buffer containing raw EXIF data, if present\n * - `icc`: Buffer containing raw [ICC](https://www.npmjs.com/package/icc) profile data, if present\n * - `iptc`: Buffer containing raw IPTC data, if present\n * - `xmp`: Buffer containing raw XMP data, if present\n * - `tifftagPhotoshop`: Buffer containing raw TIFFTAG_PHOTOSHOP data, if present\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .metadata()\n *   .then(function(metadata) {\n *     return image\n *       .resize(Math.round(metadata.width / 2))\n *       .webp()\n *       .toBuffer();\n *   })\n *   .then(function(data) {\n *     // data contains a WebP image half the width and height of the original JPEG\n *   });\n *\n * @param {Function} [callback] - called with the arguments `(err, metadata)`\n * @returns {Promise<Object>|Sharp}\n */\nfunction metadata (callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.metadata(this.options, callback);\n      });\n    } else {\n      sharp.metadata(this.options, callback);\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        this.on('finish', () => {\n          this._flattenBufferIn();\n          sharp.metadata(this.options, (err, metadata) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(metadata);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.metadata(this.options, (err, metadata) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(metadata);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Access to pixel-derived image statistics for every channel in the image.\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `channels`: Array of channel statistics for each channel in the image. Each channel statistic contains\n *     - `min` (minimum value in the channel)\n *     - `max` (maximum value in the channel)\n *     - `sum` (sum of all values in a channel)\n *     - `squaresSum` (sum of squared values in a channel)\n *     - `mean` (mean of the values in a channel)\n *     - `stdev` (standard deviation for the values in a channel)\n *     - `minX` (x-coordinate of one of the pixel where the minimum lies)\n *     - `minY` (y-coordinate of one of the pixel where the minimum lies)\n *     - `maxX` (x-coordinate of one of the pixel where the maximum lies)\n *     - `maxY` (y-coordinate of one of the pixel where the maximum lies)\n * - `isOpaque`: Value to identify if the image is opaque or transparent, based on the presence and use of alpha channel\n * - `entropy`: Histogram-based estimation of greyscale entropy, discarding alpha channel if any (experimental)\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .stats()\n *   .then(function(stats) {\n *      // stats contains the channel-wise statistics array and the isOpaque value\n *   });\n *\n * @param {Function} [callback] - called with the arguments `(err, stats)`\n * @returns {Promise<Object>}\n */\nfunction stats (callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.stats(this.options, callback);\n      });\n    } else {\n      sharp.stats(this.options, callback);\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        this.on('finish', function () {\n          this._flattenBufferIn();\n          sharp.stats(this.options, (err, stats) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(stats);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.stats(this.options, (err, stats) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(stats);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * @private\n */\nconst limitInputPixels = util.deprecate(function limitInputPixels (limit) {\n  // if we pass in false we represent the integer as 0 to disable\n  if (limit === false) {\n    limit = 0;\n  } else if (limit === true) {\n    limit = Math.pow(0x3FFF, 2);\n  }\n  if (is.integer(limit) && limit >= 0) {\n    this.options.input.limitInputPixels = limit;\n  } else {\n    throw is.invalidParameterError('limitInputPixels', 'integer', limit);\n  }\n  return this;\n}, 'limitInputPixels is deprecated, use sharp(input, { limitInputPixels: false }) instead');\n\n/**\n * @private\n */\nconst sequentialRead = util.deprecate(function sequentialRead (sequentialRead) {\n  this.options.input.sequentialRead = is.bool(sequentialRead) ? sequentialRead : true;\n  return this;\n}, 'sequentialRead is deprecated, use sharp(input, { sequentialRead: true }) instead');\n\n/**\n * Decorate the Sharp prototype with input-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Private\n    _createInputDescriptor,\n    _write,\n    _flattenBufferIn,\n    _isStreamInput,\n    // Public\n    metadata,\n    stats,\n    // Deprecated\n    limitInputPixels,\n    sequentialRead\n  });\n};\n"]},"metadata":{},"sourceType":"script"}