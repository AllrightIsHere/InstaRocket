{"ast":null,"code":"'use strict';\n\nconst is = require('./is');\n/**\n * Boolean operations for bandbool.\n * @private\n */\n\n\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n/**\n * Remove alpha channel, if any. This is a no-op if the image does not have an alpha channel.\n *\n * @example\n * sharp('rgba.png')\n *   .removeAlpha()\n *   .toFile('rgb.png', function(err, info) {\n *     // rgb.png is a 3 channel image without an alpha channel\n *   });\n *\n * @returns {Sharp}\n */\n\nfunction removeAlpha() {\n  this.options.removeAlpha = true;\n  return this;\n}\n/**\n * Ensure alpha channel, if missing. The added alpha channel will be fully opaque. This is a no-op if the image already has an alpha channel.\n *\n * @since 0.21.2\n *\n * @example\n * sharp('rgb.jpg')\n *   .ensureAlpha()\n *   .toFile('rgba.png', function(err, info) {\n *     // rgba.png is a 4 channel image with a fully opaque alpha channel\n *   });\n *\n * @returns {Sharp}\n */\n\n\nfunction ensureAlpha() {\n  this.options.ensureAlpha = true;\n  return this;\n}\n/**\n * Extract a single channel from a multi-channel image.\n *\n * @example\n * sharp(input)\n *   .extractChannel('green')\n *   .toFile('input_green.jpg', function(err, info) {\n *     // info.channels === 1\n *     // input_green.jpg contains the green channel of the input image\n *    });\n *\n * @param {Number|String} channel - zero-indexed band number to extract, or `red`, `green` or `blue` as alternative to `0`, `1` or `2` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\n\n\nfunction extractChannel(channel) {\n  if (channel === 'red') {\n    channel = 0;\n  } else if (channel === 'green') {\n    channel = 1;\n  } else if (channel === 'blue') {\n    channel = 2;\n  }\n\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw is.invalidParameterError('channel', 'integer or one of: red, green, blue', channel);\n  }\n\n  return this;\n}\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp: JPEG, PNG, WebP, GIF, SVG, TIFF or raw pixel image data.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<String|Buffer>|String|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction joinChannel(images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n\n  return this;\n}\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {String} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction bandbool(boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);\n  }\n\n  return this;\n}\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @private\n */\n\n\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public instance functions\n    removeAlpha,\n    ensureAlpha,\n    extractChannel,\n    joinChannel,\n    bandbool\n  }); // Class attributes\n\n  Sharp.bool = bool;\n};","map":{"version":3,"sources":["/media/gabriel/HD/Cursos/OmniStack 7.0/aulas/node_modules/sharp/lib/channel.js"],"names":["is","require","bool","and","or","eor","removeAlpha","options","ensureAlpha","extractChannel","channel","integer","inRange","invalidParameterError","joinChannel","images","Array","isArray","forEach","image","joinChannelIn","push","_createInputDescriptor","bandbool","boolOp","string","inArray","bandBoolOp","module","exports","Sharp","Object","assign","prototype"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,MAAD,CAAlB;AAEA;;;;;;AAIA,MAAMC,IAAI,GAAG;AACXC,EAAAA,GAAG,EAAE,KADM;AAEXC,EAAAA,EAAE,EAAE,IAFO;AAGXC,EAAAA,GAAG,EAAE;AAHM,CAAb;AAMA;;;;;;;;;;;;;AAYA,SAASC,WAAT,GAAwB;AACtB,OAAKC,OAAL,CAAaD,WAAb,GAA2B,IAA3B;AACA,SAAO,IAAP;AACD;AAED;;;;;;;;;;;;;;;;AAcA,SAASE,WAAT,GAAwB;AACtB,OAAKD,OAAL,CAAaC,WAAb,GAA2B,IAA3B;AACA,SAAO,IAAP;AACD;AAED;;;;;;;;;;;;;;;;;AAeA,SAASC,cAAT,CAAyBC,OAAzB,EAAkC;AAChC,MAAIA,OAAO,KAAK,KAAhB,EAAuB;AACrBA,IAAAA,OAAO,GAAG,CAAV;AACD,GAFD,MAEO,IAAIA,OAAO,KAAK,OAAhB,EAAyB;AAC9BA,IAAAA,OAAO,GAAG,CAAV;AACD,GAFM,MAEA,IAAIA,OAAO,KAAK,MAAhB,EAAwB;AAC7BA,IAAAA,OAAO,GAAG,CAAV;AACD;;AACD,MAAIV,EAAE,CAACW,OAAH,CAAWD,OAAX,KAAuBV,EAAE,CAACY,OAAH,CAAWF,OAAX,EAAoB,CAApB,EAAuB,CAAvB,CAA3B,EAAsD;AACpD,SAAKH,OAAL,CAAaE,cAAb,GAA8BC,OAA9B;AACD,GAFD,MAEO;AACL,UAAMV,EAAE,CAACa,qBAAH,CAAyB,SAAzB,EAAoC,qCAApC,EAA2EH,OAA3E,CAAN;AACD;;AACD,SAAO,IAAP;AACD;AAED;;;;;;;;;;;;;;;;;;AAgBA,SAASI,WAAT,CAAsBC,MAAtB,EAA8BR,OAA9B,EAAuC;AACrC,MAAIS,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAJ,EAA2B;AACzBA,IAAAA,MAAM,CAACG,OAAP,CAAe,UAAUC,KAAV,EAAiB;AAC9B,WAAKZ,OAAL,CAAaa,aAAb,CAA2BC,IAA3B,CAAgC,KAAKC,sBAAL,CAA4BH,KAA5B,EAAmCZ,OAAnC,CAAhC;AACD,KAFD,EAEG,IAFH;AAGD,GAJD,MAIO;AACL,SAAKA,OAAL,CAAaa,aAAb,CAA2BC,IAA3B,CAAgC,KAAKC,sBAAL,CAA4BP,MAA5B,EAAoCR,OAApC,CAAhC;AACD;;AACD,SAAO,IAAP;AACD;AAED;;;;;;;;;;;;;;;;;;AAgBA,SAASgB,QAAT,CAAmBC,MAAnB,EAA2B;AACzB,MAAIxB,EAAE,CAACyB,MAAH,CAAUD,MAAV,KAAqBxB,EAAE,CAAC0B,OAAH,CAAWF,MAAX,EAAmB,CAAC,KAAD,EAAQ,IAAR,EAAc,KAAd,CAAnB,CAAzB,EAAmE;AACjE,SAAKjB,OAAL,CAAaoB,UAAb,GAA0BH,MAA1B;AACD,GAFD,MAEO;AACL,UAAMxB,EAAE,CAACa,qBAAH,CAAyB,QAAzB,EAAmC,sBAAnC,EAA2DW,MAA3D,CAAN;AACD;;AACD,SAAO,IAAP;AACD;AAED;;;;;;AAIAI,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AAChCC,EAAAA,MAAM,CAACC,MAAP,CAAcF,KAAK,CAACG,SAApB,EAA+B;AAC7B;AACA3B,IAAAA,WAF6B;AAG7BE,IAAAA,WAH6B;AAI7BC,IAAAA,cAJ6B;AAK7BK,IAAAA,WAL6B;AAM7BS,IAAAA;AAN6B,GAA/B,EADgC,CAShC;;AACAO,EAAAA,KAAK,CAAC5B,IAAN,GAAaA,IAAb;AACD,CAXD","sourcesContent":["'use strict';\n\nconst is = require('./is');\n\n/**\n * Boolean operations for bandbool.\n * @private\n */\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n\n/**\n * Remove alpha channel, if any. This is a no-op if the image does not have an alpha channel.\n *\n * @example\n * sharp('rgba.png')\n *   .removeAlpha()\n *   .toFile('rgb.png', function(err, info) {\n *     // rgb.png is a 3 channel image without an alpha channel\n *   });\n *\n * @returns {Sharp}\n */\nfunction removeAlpha () {\n  this.options.removeAlpha = true;\n  return this;\n}\n\n/**\n * Ensure alpha channel, if missing. The added alpha channel will be fully opaque. This is a no-op if the image already has an alpha channel.\n *\n * @since 0.21.2\n *\n * @example\n * sharp('rgb.jpg')\n *   .ensureAlpha()\n *   .toFile('rgba.png', function(err, info) {\n *     // rgba.png is a 4 channel image with a fully opaque alpha channel\n *   });\n *\n * @returns {Sharp}\n */\nfunction ensureAlpha () {\n  this.options.ensureAlpha = true;\n  return this;\n}\n\n/**\n * Extract a single channel from a multi-channel image.\n *\n * @example\n * sharp(input)\n *   .extractChannel('green')\n *   .toFile('input_green.jpg', function(err, info) {\n *     // info.channels === 1\n *     // input_green.jpg contains the green channel of the input image\n *    });\n *\n * @param {Number|String} channel - zero-indexed band number to extract, or `red`, `green` or `blue` as alternative to `0`, `1` or `2` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\nfunction extractChannel (channel) {\n  if (channel === 'red') {\n    channel = 0;\n  } else if (channel === 'green') {\n    channel = 1;\n  } else if (channel === 'blue') {\n    channel = 2;\n  }\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw is.invalidParameterError('channel', 'integer or one of: red, green, blue', channel);\n  }\n  return this;\n}\n\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp: JPEG, PNG, WebP, GIF, SVG, TIFF or raw pixel image data.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<String|Buffer>|String|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction joinChannel (images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {String} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction bandbool (boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public instance functions\n    removeAlpha,\n    ensureAlpha,\n    extractChannel,\n    joinChannel,\n    bandbool\n  });\n  // Class attributes\n  Sharp.bool = bool;\n};\n"]},"metadata":{},"sourceType":"script"}